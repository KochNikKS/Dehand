#!/usr/bin/python3
import sys
import os
import re
import platform
import locale
import tkinter
import shutil
from tkinter import ttk
from tkinter import filedialog
from tkinter import simpledialog
from tkinter import messagebox
from urllib import request
import threading
import time
import json
import cProfile
import pstats

DP = locale.localeconv()['decimal_point']
if DP == '.':
    nonDP = ','
elif DP == ',':
    nonDP = '.'
else:
    nonDP = ',.'

reSTOP_SEQ = '[ \t→;{}]'.format(nonDP)
reBIG_STOP_SEQ = '[ .,!?\t→;:\-=\(\)\{\}\[\]|]'
STOP_SEQUENCE = ' \t→;' + nonDP
BIG_STOP_SEQUENCE = ' .,!?\t→;:-=()|<>{}[]|'
MED_STOP_SEQUENCE = ' ,!?\t;:|→'
SMALL_STOP_SEQUENCE = '|\t→;'
ALPHABET = 'abcdefghijklmnopqrstuvwxyz'
ARW = '→'
PRF = '¶'
ECLASSES = ('INT', 'IND', 'ENZ', 'PHE', 'LOC', 'UNK', 'CHA', 'TRA', 'CAR', 'MIM')


AAPATTERN = '(\d+-[a-z]+-*[A-z]+-\d+)|[ .,;\t\n]([a-z]+-\d+)[ .,;!\t\n]' \
            '|([a-z]+-\d+-*\d+-[a-z]+)|[ .,;\t\n](\d+-[a-z]+)[ .,;!\t\n]'
CLASS_REGEX = r'(?:^|;|→)((\[)*(INT|IND|ENZ|PHE|LOC|UNK|CHA|TRA|CAR|MIM)(\?|\])*)'
LEVEL_REGEX = '[-+0?r!]+'
TARGET_REGEX = '[^\|^;]'
AALINK_REGEX = '([^;^#^{}]+)'.format(PRF)
NECESSARY_FILES = ('processing.mem', 'actions.lst', 'rep.lst', 'modifiers.lst', 'help.txt', 
                   'inserts.lst', 'partlinkers.lst', 'replacers.lst', 'precedents.mem')
ABSOLUTELY_NECESSARY_FILES = ('actions.lst', 'modifiers.lst', 'partlinkers.lst', 'replacers.lst')


class StringEditor:
    def __init__(self):
        self.EditWindow = tkinter.Tk()
        self.EditWindow.wm_title('"mutation-effect" descriptions handler        ')
        self.EditWindow.minsize(640, 480)
        # ---------------
        self.help_window = tkinter.Toplevel(self.EditWindow)
        self.help_window.wm_title('?')
        self.help_window_frame1 = tkinter.Frame(self.help_window, height=20)
        self.help_window_frame2 = tkinter.Frame(self.help_window, height=20)
        self.help_window_frame1.pack(side='top', fill='x')
        self.help_window_frame2.pack(side='top', fill='both', expand=True)
        self.search_button = tkinter.ttk.Button(self.help_window_frame1, text='Search and highlight',
                                                command=self.text_search)
        self.search_button.pack(side='left', anchor='nw')
        self.search_field = tkinter.Entry(self.help_window_frame1, width=40)
        self.search_field.pack(side='left', anchor='nw', fill='both', expand=True)
        self.search_field.bind('<Return>', self.text_search)
        self.help_txt_box = tkinter.Text(self.help_window_frame2, relief='flat', wrap=tkinter.WORD,
                                         font=("Courier", 12))
        self.help_txt_box.pack(side='left', fill='both', expand=True)
        self.scroller = tkinter.ttk.Scrollbar(self.help_window_frame2, command=self.help_txt_box.yview)
        self.scroller.pack(side='left', fill='y')
        self.help_txt_box.configure(yscrollcommand=self.scroller.set)
        self.help_window.protocol("WM_DELETE_WINDOW", self.help_window.withdraw)
        self.help_txt_box.bind('<Button-1>', self.clear_tags)
        self.help_window.bind('<Control-KeyPress-f>', self.focus_set_wrp)
        self.help_window.bind('<Control-KeyPress-F>', self.focus_set_wrp)
        self.help_window.withdraw()
        # ---------------
        self.ins_window = tkinter.Toplevel(self.EditWindow)
        self.ins_window.title('Insertions')
        self.num_frame = tkinter.Frame(self.ins_window)
        self.ins_frame = tkinter.Frame(self.ins_window)
        self.num_frame.place(x=1, y=1, width=20, height=200)
        self.ins_frame.place(x=20, y=1, width=300, height=230)
        self.ins_fields = []
        for i in range(10):
            entry = tkinter.Entry(self.ins_frame, width=40)
            num_e = tkinter.Entry(self.num_frame, width=2, bg='white')
            num_e.insert(0, str(i))
            num_e.configure(state='disabled')
            num_e.pack(side='top', anchor='nw')
            entry.pack(side='top', anchor='nw', fill='x')
            self.ins_fields.append(entry)
        self.use_but = tkinter.ttk.Button(self.ins_frame, text='Store changes', command=self.use_inserts)
        self.use_but.pack(side='top', anchor='ne')
        self.ins_window.resizable(height=False, width=False)
        self.ins_window.geometry('325x230')
        self.ins_window.protocol("WM_DELETE_WINDOW", self.ins_window.withdraw)
        self.ins_window.withdraw()
        # ----------------

        self.replace_window = tkinter.Toplevel(self.EditWindow)
        self.replace_window.wm_title('Search and replace')
        self.replace_window.resizable(True, 0)
        self.search_entry = tkinter.Entry(self.replace_window, width=80, font=("Courier", 10))
        self.replace_entry = tkinter.Entry(self.replace_window, width=80, font=("Courier", 10))
        self.replace_button = tkinter.ttk.Button(self.replace_window, text='replace', command=self.replace_words)
        self.search_entry.pack(side='top', fill='x', expand=True)
        self.replace_entry.pack(side='top', fill='x', expand=True)
        self.replace_button.pack(side='right')
        self.replace_window.protocol("WM_DELETE_WINDOW", self.close_replace_dialog)
        self.search_entry.bind('<Control-KeyPress-H>', self.replace_words)
        self.search_entry.bind('<Control-KeyPress-h>', self.replace_words)
        self.replace_entry.bind('<Control-KeyPress-H>', self.replace_words)
        self.replace_entry.bind('<Control-KeyPress-h>', self.replace_words)
        self.replace_window.withdraw()

        self.frame1 = tkinter.Frame(self.EditWindow, height=20)
        self.frame1.pack(side=tkinter.TOP, fill='x')
        self.frame2 = tkinter.Frame(self.EditWindow, height=300)
        self.frame2.pack(side=tkinter.TOP, fill='both', expand=True)
        self.frame3 = tkinter.Frame(self.EditWindow, height=280)
        self.frame3.pack(side=tkinter.TOP, fill='both', expand=True)


        self.load_file_button = ttk.Button(self.frame1, text=' Load ', command=self.open_new_source, width=6)
        self.next_button = ttk.Button(self.frame1, text=' Next ', command=self.next_string, width=6)
        self.split_button = ttk.Button(self.frame1, text=' Split ', command=self.split_line, width=6)
        self.mark_button = ttk.Button(self.frame1, text='Mark part', command=self.mem_excision1, width=11)
        self.reload_string_button = ttk.Button(self.frame1, text='Reload str.', command=self.load_str, width=11)
        self.undo_button = ttk.Button(self.frame1, text=' Undo ', command=self.undo, width=6)
        self.jump_button = ttk.Button(self.frame1, text=' Jump to ', command=self.jump_to, width=8)
        self.back_button = ttk.Button(self.frame1, text=' Back ', command=self.step_back, width=6)
        self.show_replace_dialog = ttk.Button(self.frame1, text='Replace', command=self.show_replace_window, width=7)
        self.ins_list_button = tkinter.ttk.Button(self.frame1, text='Insertions', command=self.show_ins_list)

        self.copy_menu = tkinter.Menu(self.EditWindow, tearoff=0)
        self.copy_menu.add_command(label='directly into activity/partner position', command=self.target_copy)
        self.copy_menu.add_separator()
        self.copy_menu.add_command(label='to clipboard', command=self.copy_to_clipboard)
        self.copy_menu.add_separator()
        self.copy_menu.add_command(label='< cancel >', command=self.copy_menu.unpost)
        self.copy_button = ttk.Menubutton(self.frame1, text='Copy', menu=self.copy_menu)

        self.ins_menu = tkinter.Menu(self.EditWindow, tearoff=0)
        self.ins_menu.add_command(label='activity/partner from clipboard', command=self.target_paste)
        self.ins_menu.add_separator()
        self.ins_menu.add_command(label='? as activity/partner', command=self.question_mark_3rd_block)
        self.ins_menu.add_separator()
        self.ins_menu.add_command(label='same protein as activity/partner',
                                  command=lambda: self.target_paste(mode='add', paste_instead=self.upID))
        self.ins_menu.add_separator()
        self.ins_menu.add_command(label='from clipboard', command=self.paste)
        self.ins_menu.add_separator()
        self.ins_menu.add_command(label='Flank selection by [ ]', command=self.bracket_flank)
        self.ins_menu.add_separator()
        self.ins_menu.add_command(label='< cancel >', command=self.ins_menu.unpost)
        self.ins_button = ttk.Menubutton(self.frame1, text='Insert', menu=self.ins_menu)

        self.level_menu = tkinter.Menu(self.EditWindow, tearoff=0)
        self.level_menu.add_command(label='Insert -- level', command=lambda: self.set_level(level='--', replace=False))
        self.level_menu.add_separator()
        self.level_menu.add_command(label='Insert - level', command=lambda: self.set_level(level='-', replace=False))
        self.level_menu.add_separator()
        self.level_menu.add_command(label='Insert 0 level', command=lambda: self.set_level(level='0', replace=False))
        self.level_menu.add_separator()
        self.level_menu.add_command(label='Insert ? level', command=lambda: self.set_level(level='?', replace=False))
        self.level_menu.add_separator()
        self.level_menu.add_command(label='Insert + level', command=lambda: self.set_level(level='+', replace=False))
        self.level_menu.add_separator()
        self.level_menu.add_command(label='Insert ++ level', command=lambda: self.set_level(level='++', replace=False))
        self.level_menu.add_separator()
        self.level_menu.add_command(label='Insert r level', command=lambda: self.set_level(level='r', replace=False))
        self.level_menu.add_separator()
        self.level_menu.add_command(label='Insert !', command=lambda: self.set_level(level='!', replace=False))
        self.level_menu.add_separator()
        self.level_menu.add_command(label='< cancel >', command=self.level_menu.unpost)
        self.ins_level_button = ttk.Menubutton(self.frame1, text='Insert grade', menu=self.level_menu)

        self.type_menu = tkinter.Menu(self.EditWindow, tearoff=0)
        self.type_menu.add_command(label='Insert INT', command=lambda: self.ins_class(eclass='INT', replace=False))
        self.type_menu.add_separator()
        self.type_menu.add_command(label='Insert IND', command=lambda: self.ins_class(eclass='IND', replace=False))
        self.type_menu.add_separator()
        self.type_menu.add_command(label='Insert ENZ', command=lambda: self.ins_class(eclass='ENZ', replace=False))
        self.type_menu.add_separator()
        self.type_menu.add_command(label='Insert PHE', command=lambda: self.ins_class(eclass='PHE', replace=False))
        self.type_menu.add_separator()
        self.type_menu.add_command(label='Insert LOC', command=lambda: self.ins_class(eclass='LOC', replace=False))
        self.type_menu.add_separator()
        self.type_menu.add_command(label='Insert TRA', command=lambda: self.ins_class(eclass='TRA', replace=False))
        self.type_menu.add_command(label='Insert CHA', command=lambda: self.ins_class(eclass='CHA', replace=False))
        self.type_menu.add_command(label='Insert CAR', command=lambda: self.ins_class(eclass='CAR', replace=False))
        self.type_menu.add_separator()
        self.type_menu.add_command(label='Insert UNK', command=lambda: self.ins_class(eclass='UNK', replace=False))
        self.type_menu.add_separator()
        self.type_menu.add_command(label='Insert MIM', command=lambda: self.ins_class(eclass='MIM', replace=False))
        self.type_menu.add_separator()
        self.type_menu.add_command(label='< cancel >', command=self.type_menu.unpost)
        self.ins_type_button = ttk.Menubutton(self.frame1, text='Insert class', menu=self.type_menu)

        self.help_button = ttk.Button(self.frame1, text=' ? ', command=self.help, width='3')
        self.uniprot_button = ttk.Button(self.frame1, text='? UniProt', command=self.show_uniprot_entry)
        self.source_button = ttk.Button(self.frame1, text='? src. file', command=self.view_source)
        self.plus_font_button = ttk.Button(self.frame1, text='+', command=self.plus_font, width='3')
        self.minus_font_button = ttk.Button(self.frame1, text='-', command=self.minus_font, width='3')
        self.t_editor = tkinter.Text(self.frame2, height=15, font=("Courier", 12))
        self.file_label = tkinter.Label(self.frame2, text='File name:', anchor='w', font=("Courier", 10))
        self.id_field = tkinter.Label(self.frame2, text='Current ID: ', justify=tkinter.LEFT)
        self.logic_but = tkinter.ttk.Button(self.frame2, text='Reload logic', command=self.reload_logic)

        self.console = tkinter.Text(self.frame3, bg='steelblue', fg='white', relief='flat')
        self.console_scrooler = ttk.Scrollbar(self.frame3, orient='vertical', command=self.console.yview)
        self.console.configure(yscrollcommand = self.console_scrooler.set)

        self.load_file_button.pack(side=tkinter.LEFT, anchor='nw')
        self.reload_string_button.pack(side=tkinter.LEFT, anchor='nw')
        self.undo_button.pack(side=tkinter.LEFT, anchor='nw')
        self.split_button.pack(side=tkinter.LEFT, anchor='nw')
        self.mark_button.pack(side=tkinter.LEFT, anchor='nw')
        self.next_button.pack(side=tkinter.LEFT, anchor='nw')
        self.jump_button.pack(side=tkinter.LEFT, anchor='nw')
        self.back_button.pack(side=tkinter.LEFT, anchor='nw')
        self.show_replace_dialog.pack(side=tkinter.LEFT, anchor='nw')
        self.ins_list_button.pack(side=tkinter.LEFT, anchor='nw')
        self.separator = tkinter.Frame(self.frame1, width=30)
        self.separator.pack(side=tkinter.LEFT, anchor='nw', fill='y')
        self.ins_level_button.pack(side=tkinter.LEFT, anchor='nw')
        self.ins_type_button.pack(side=tkinter.LEFT, anchor='nw')
        self.copy_button.pack(side=tkinter.LEFT, anchor='nw')
        self.ins_button.pack(side=tkinter.LEFT, anchor='nw')
        self.help_button.pack(side=tkinter.RIGHT, anchor='ne')
        self.uniprot_button.pack(side=tkinter.RIGHT, anchor='ne')
        self.source_button.pack(side=tkinter.RIGHT, anchor='ne')
        self.plus_font_button.pack(side=tkinter.RIGHT, anchor='ne')
        self.minus_font_button.pack(side=tkinter.RIGHT, anchor='ne')
        self.t_editor.pack(side=tkinter.TOP, anchor='n', fill=tkinter.BOTH, expand=True)
        self.file_label.pack(side=tkinter.LEFT, anchor='nw')
        self.id_field.pack(side=tkinter.LEFT, anchor='nw', fill='x', expand=True)
        self.logic_but.pack(side=tkinter.LEFT, anchor='nw', fill='x')

        self.console.pack(side=tkinter.LEFT, fill='both', expand=True)
        self.console_scrooler.pack(side=tkinter.LEFT, fill='y')

        self.EditWindow.bind('<Control-KeyPress-l>', self.open_new_source)
        self.EditWindow.bind('<Control-KeyPress-L>', self.open_new_source)
        self.t_editor.bind('<Control-KeyPress-F>', self.find_in_uniprot)
        self.t_editor.bind('<Control-KeyPress-f>', self.find_in_uniprot)
        self.help_window.bind('<Control-KeyPress-e>', lambda event: self.focus_on(object_to_focus_on=self.t_editor))
        self.EditWindow.bind('<Control-KeyPress-z>', self.undo)
        self.EditWindow.bind('<Control-KeyPress-Z>', self.undo)
        self.EditWindow.bind('<Control-space>', self.next_string)
        self.EditWindow.bind('<Control-Return>', self.next_string)
        self.EditWindow.bind('<Control-BackSpace>', self.step_back)
        self.EditWindow.bind('<Control-Tab>', self.undo)
        self.t_editor.bind('<Control-KeyPress-s>', self.split_line)
        self.t_editor.bind('<Control-KeyPress-S>', self.split_line)
        self.t_editor.bind('<Alt-KeyPress-Z>', self.split_line)
        self.t_editor.bind('<Alt-KeyPress-z>', self.split_line)
        self.t_editor.bind('<Control-KeyPress-D>', self.duplicate_line)
        self.t_editor.bind('<Control-KeyPress-d>', self.duplicate_line)
        self.t_editor.bind('<Control-Alt-KeyPress-x>', self.mem_excision1)
        self.t_editor.bind('<Control-Alt-KeyPress-X>', self.mem_excision1)
        self.t_editor.bind('<Alt-KeyPress-x>', self.mem_excision1)
        self.t_editor.bind('<Alt-KeyPress-X>', self.mem_excision1)
        self.EditWindow.bind('<Control-KeyPress-r>', self.load_str)
        self.EditWindow.bind('<Control-KeyPress-R>', self.load_str)
        self.EditWindow.bind('<Control-Alt-KeyPress-r>', lambda event: self.load_str(consider_precedents=False))
        self.EditWindow.bind('<Control-Alt-KeyPress-R>', lambda event: self.load_str(consider_precedents=False))
        self.EditWindow.bind('<Control-Alt-KeyPress-L>', self.reload_logic)
        self.EditWindow.bind('<Control-Alt-KeyPress-l>', self.reload_logic)
        self.EditWindow.bind('<Alt-backslash>', self.move_to_description)
        self.EditWindow.bind('<Control-backslash>', self.move_to_description)
        self.t_editor.bind('<Alt-Home>', self.move_to_description_start)
        self.t_editor.bind('<Alt-End>', self.alt_end)
        self.t_editor.bind('<Control-Home>', self.move_to_description_start)
        self.t_editor.bind('<Control-Alt-End>', self.move_to_level)

        self.t_editor.bind('<Control-h>', self.show_replace_window)
        self.t_editor.bind('<Control-H>', self.show_replace_window)
        self.t_editor.bind('<Alt-KeyPress-1>', lambda event: self.ins_class(eclass='INT', replace=False))
        self.t_editor.bind('<Alt-KeyPress-2>', lambda event: self.ins_class(eclass='IND', replace=False))
        self.t_editor.bind('<Alt-KeyPress-3>', lambda event: self.ins_class(eclass='ENZ', replace=False))
        self.t_editor.bind('<Alt-KeyPress-4>', lambda event: self.ins_class(eclass='PHE', replace=False))
        self.t_editor.bind('<Alt-KeyPress-5>', lambda event: self.ins_class(eclass='LOC', replace=False))
        self.t_editor.bind('<Alt-KeyPress-6>', lambda event: self.ins_class(eclass='UNK', replace=False))
        self.t_editor.bind('<Alt-KeyPress-7>', lambda event: self.ins_class(eclass='CHA', replace=False))
        self.t_editor.bind('<Alt-KeyPress-8>', lambda event: self.ins_class(eclass='TRA', replace=False))
        self.t_editor.bind('<Alt-KeyPress-9>', lambda event: self.ins_class(eclass='CAR', replace=False))
        self.t_editor.bind('<Alt-KeyPress-q>', lambda event: self.ins_class(eclass='PHE', replace=False))
        self.t_editor.bind('<Alt-KeyPress-Q>', lambda event: self.ins_class(eclass='PHE', replace=False))
        self.t_editor.bind('<Alt-KeyPress-w>', lambda event: self.ins_class(eclass='LOC', replace=False))
        self.t_editor.bind('<Alt-KeyPress-W>', lambda event: self.ins_class(eclass='LOC', replace=False))
        self.t_editor.bind('<Alt-KeyPress-e>', lambda event: self.ins_class(eclass='UNK', replace=False))
        self.t_editor.bind('<Alt-KeyPress-E>', lambda event: self.ins_class(eclass='UNK', replace=False))
        self.t_editor.bind('<Alt-KeyPress-A>', lambda event: self.ins_class(eclass='CHA', replace=False))
        self.t_editor.bind('<Alt-KeyPress-a>', lambda event: self.ins_class(eclass='CHA', replace=False))
        self.t_editor.bind('<Alt-KeyPress-S>', lambda event: self.ins_class(eclass='TRA', replace=False))
        self.t_editor.bind('<Alt-KeyPress-s>', lambda event: self.ins_class(eclass='TRA', replace=False))
        self.t_editor.bind('<Alt-KeyPress-D>', lambda event: self.ins_class(eclass='CAR', replace=False))
        self.t_editor.bind('<Alt-KeyPress-d>', lambda event: self.ins_class(eclass='CAR', replace=False))
        self.t_editor.bind('<Alt-KeyPress-F>', lambda event: self.ins_class(eclass='MIM', replace=False))
        self.t_editor.bind('<Alt-KeyPress-f>', lambda event: self.ins_class(eclass='MIM', replace=False))

        self.t_editor.bind('<Control-Alt-KeyPress-1>', lambda event: self.ins_class(eclass='INT', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-2>', lambda event: self.ins_class(eclass='IND', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-3>', lambda event: self.ins_class(eclass='ENZ', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-4>', lambda event: self.ins_class(eclass='PHE', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-5>', lambda event: self.ins_class(eclass='LOC', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-6>', lambda event: self.ins_class(eclass='UNK', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-7>', lambda event: self.ins_class(eclass='CHA', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-8>', lambda event: self.ins_class(eclass='TRA', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-9>', lambda event: self.ins_class(eclass='CAR', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-q>', lambda event: self.ins_class(eclass='PHE', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-Q>', lambda event: self.ins_class(eclass='PHE', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-w>', lambda event: self.ins_class(eclass='LOC', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-W>', lambda event: self.ins_class(eclass='LOC', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-e>', lambda event: self.ins_class(eclass='UNK', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-E>', lambda event: self.ins_class(eclass='UNK', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-A>', lambda event: self.ins_class(eclass='CHA', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-a>', lambda event: self.ins_class(eclass='CHA', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-S>', lambda event: self.ins_class(eclass='TRA', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-s>', lambda event: self.ins_class(eclass='TRA', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-D>', lambda event: self.ins_class(eclass='CAR', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-d>', lambda event: self.ins_class(eclass='CAR', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-F>', lambda event: self.ins_class(eclass='MIM', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-f>', lambda event: self.ins_class(eclass='MIM', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-0>', lambda event: self.set_level(level='0', replace=True))
        self.t_editor.bind('<Alt-KeyPress-0>', lambda event: self.set_level(level='0', replace=False))

        self.t_editor.bind('<Alt-decimalpoint>', lambda event: self.set_level(level='?', replace=False))
        self.t_editor.bind('<Alt-slash>', lambda event: self.set_level(level='?', replace=False))
        self.t_editor.bind('<Control-Alt-decimalpoint>', lambda event: self.set_level(level='?', replace=True))
        self.t_editor.bind('<Control-Alt-slash>', lambda event: self.set_level(level='?', replace=True))

        self.t_editor.bind('<Control-Alt-minus>', lambda event: self.set_level(level='-', replace=True))
        self.t_editor.bind('<Alt-minus->', lambda event: self.set_level(level='-', replace=False))
        self.t_editor.bind('<Control-Alt-underscore>', lambda event: self.set_level(level='--', replace=True))
        self.t_editor.bind('<Alt-underscore->', lambda event: self.set_level(level='--', replace=False))
        self.t_editor.bind('<Control-Alt-plus>', lambda event: self.set_level(level='++', replace=True))
        self.t_editor.bind('<Alt-plus>', lambda event: self.set_level(level='++', replace=False))
        self.t_editor.bind('<Control-Alt-equal>', lambda event: self.set_level(level='+', replace=True))
        self.t_editor.bind('<Alt-equal>', lambda event: self.set_level(level='+', replace=False))
        self.t_editor.bind('<Alt-KeyPress-r>', lambda event: self.set_level(level='r', replace=False))
        self.t_editor.bind('<Alt-KeyPress-R>', lambda event: self.set_level(level='r', replace=False))
        self.t_editor.bind('<Control-Alt-KeyPress-r>', lambda event: self.set_level(level='r', replace=True))
        self.t_editor.bind('<Control-Alt-KeyPress-R>', lambda event: self.set_level(level='r', replace=True))
        self.t_editor.bind('<Alt-KeyPress-exclam>', lambda event: self.set_level(level='!', replace=False))
        self.t_editor.bind('<Control-Alt-KeyPress-exclam>', lambda event: self.set_level(level='!', replace=True))
        self.t_editor.bind('<Alt-KeyPress-bracketleft>', self.bracket_flank)
        self.EditWindow.bind('<KeyPress>', self.on_edit)
        self.EditWindow.bind('<F1>', self.help)
        self.EditWindow.bind('<F2>', self.show_uniprot_entry)
        self.EditWindow.bind('<F3>', self.view_source)
        self.EditWindow.bind('<F4>', self.replace_words)
        self.EditWindow.bind('<F5>', self.set_new_grades)
        self.EditWindow.bind('<F6>', self.show_ins_list)
        self.EditWindow.bind('<F7>', self.use_precedents_for_all)
        self.t_editor.bind('<Alt-KeyPress-c>', lambda event: self.target_copy(mode_to_pass='add'))
        self.t_editor.bind('<Alt-KeyPress-C>', lambda event: self.target_copy(mode_to_pass='add'))
        self.t_editor.bind('<Control-Alt-KeyPress-c>', lambda event: self.target_copy(mode_to_pass='split'))
        self.t_editor.bind('<Control-Alt-KeyPress-C>', lambda event: self.target_copy(mode_to_pass='split'))
        self.t_editor.bind('<Alt-KeyPress-v>', lambda event: self.target_paste(mode='add'))
        self.t_editor.bind('<Alt-KeyPress-V>', lambda event: self.target_paste(mode='add'))
        self.t_editor.bind('<Control-Alt-KeyPress-v>', lambda event: self.target_paste(mode='split'))
        self.t_editor.bind('<Control-Alt-KeyPress-V>', lambda event: self.target_paste(mode='split'))
        self.t_editor.bind('<Alt-question>', lambda event: self.target_paste(mode='add',
                                                                             buffered=False, paste_instead='?'))
        self.t_editor.bind('<Control-Alt-question>', lambda event: self.target_paste(mode='split',
                                                                                     buffered=False, paste_instead='?'))
        self.t_editor.bind('<Alt-Delete>', lambda event: self.target_paste(mode='delete', buffered=False))

        self.t_editor.bind('<Double-Button-1>', self.select_word)
        self.t_editor.bind('<KeyPress-Escape>', self.clear_editor_tags)        
        self.t_editor.bind('<Control-Double-Button-1>', self.alter_select_word)
        self.t_editor.bind('<Double-Button-3>', self.next_string)
        self.t_editor.bind('<Next>', self.next_string)
        self.t_editor.bind('<Prior>', self.step_back)
        self.t_editor.bind('<Alt-KeyPress-Right>', self.move_selection_right)
        self.t_editor.bind('<Alt-KeyPress-Left>', self.move_selection_left)
        self.t_editor.bind('<Control-Alt-KeyPress-Right>', self.strict_move_selection_right)
        self.t_editor.bind('<Control-Alt-KeyPress-Left>', self.strict_move_selection_left)
        self.t_editor.bind('<Alt-Shift-KeyPress-Right>', self.loose_move_selection_right)
        self.t_editor.bind('<Alt-Shift-KeyPress-Left>', self.loose_move_selection_left)

        self.t_editor.bind('<Control-KeyPress-Right>', self.to_next_word)
        self.t_editor.bind('<Control-KeyPress-Left>', self.to_previous_word)
        self.t_editor.bind('<Control-Shift-KeyPress-Left>', self.ctrl_select_left)
        self.t_editor.bind('<Control-Shift-KeyPress-Right>', self.ctrl_select_right)

        self.t_editor.bind('<Alt-period>', self.move_selection_right)
        self.t_editor.bind('<Alt-comma>', self.move_selection_left)
        self.t_editor.bind('<Control-Alt-period>', self.strict_move_selection_right)
        self.t_editor.bind('<Control-Alt-comma>', self.strict_move_selection_left)
        self.t_editor.bind('<Alt-greater>', self.loose_move_selection_right)
        self.t_editor.bind('<Alt-less>', self.loose_move_selection_left)

        # self.EditWindow.bind('<KeyPress>', self.store_inline_position)
        self.t_editor.bind('<Control-Alt-u>', lambda event: self.target_paste(mode='add', buffered=False,
                                                                              paste_instead=self.upID))
        self.EditWindow.bind('<Button-1>', self.unpost_menus)
        self.t_editor.bind('<Button-1>', self.unpost_menus)
        self.t_editor.bind('<<Modified>>', self.on_edit)
        self.EditWindow.bind('<Alt-KeyPress-{}>'.format('quoteleft' if platform.system() == 'Windows' else 'grave'),
                             self.show_ins_list)
        for num in range(10):
            self.ins_window.bind('<Control-Alt-KeyPress-{}>'.format(num), self.ins_popular)


        taskbar_height = 380 if platform.system() == 'Windows' else 0
        diff_height = 700 if self.EditWindow.winfo_screenheight() > 700 else self.EditWindow.winfo_screenheight()
        geometry = '{}x600+0+{}'.format(self.EditWindow.winfo_screenwidth()-2,
                                        self.EditWindow.winfo_screenheight() - diff_height)
        self.EditWindow.geometry(geometry)
                
        self.EditWindow.protocol("WM_DELETE_WINDOW", self.on_exit)

        self.filename = ''
        self.position = 0
        self.lines = []
        self.undo_buffer = []
        self.font_size = 12
        self.started = False
        self.excision1 = ['', 0]
        self.STOP = True
        self.upID = ''
        self.last_up_id = ''
        self.timer = 0
        self.mut_actions = {}
        self.modifiers = {}
        self.stored_current = []
        self.stored_time = time.time()
        self.stored_times = []
        self.ins_list = []
        self.process_precedents = {}
        self.help_window_mode = 0
        self.uniprot_entry = ''
        self.partlinkers = []
        self.replacers = []
        self.virt_cursor_pos = ''
        self.actions_list_cleared = ()

        self.t_editor.tag_configure('e_class', foreground='white', background='SteelBlue2')
        self.t_editor.tag_configure('level', foreground='white', background='Gold3')
        self.t_editor.tag_configure('target', foreground='white', background='PaleGreen3')
        self.t_editor.tag_configure('aa_linked', foreground='white', background='gray')
        self.t_editor.tag_configure('sel', foreground='white', background='black')

    # def showkey(self, event =''):
    #    messagebox.showinfo('', event.keysym)

    def stop_editor(self):
        self.close_replace_dialog()
        self.EditWindow.destroy()
        sys.exit()        

    @staticmethod
    def can_start(filelist: tuple):
        must_have_missed = [name for name in ABSOLUTELY_NECESSARY_FILES if name not in filelist]
        total_missed = [name for name in NECESSARY_FILES if name not in filelist]
        answer = True if len(must_have_missed) == 0 else False
        return answer, total_missed, must_have_missed
    
    def start_editor(self, f_name: str, p_num: int):
        """
        starts editor
        """
        start_is_possible, missed_files, important_missed = self.can_start(self.check_files(self.work_directory))        
        self.console_push('Missed files: ', ';'.join(missed_files) if len(missed_files) > 0 else 'None')
        if not start_is_possible:
            self.console_push('Some important file missed: ', ';'.join(important_missed))
            self.console_push('The program can not be started.')
            self.stop_editor()
        
        tmp_filename, tmp_position = self.get_start_point(self.work_directory)
        self.filename = f_name if f_name else tmp_filename
        while not self.appropriate_source(self.filename):
            self.console_push(self.filename)
            messagebox.showerror('Error', 'No proper filename provided!\n Choose file manually.')
            self.filename = filedialog.askopenfilename(title='Specify file: ', initialdir=self.work_directory)
            if not self.filename:
                self.stop_editor()
        self.t_editor.focus_force()
        # start at 0 or at stored position

        if p_num == -1:
            self.position = 0 if tmp_position == 0 else {True: tmp_position, False: 0}[messagebox.askyesno(
                'Position to start', 'Start at stored position ( {} )? '
                '\n\n*There is(are) {} processed line(s) in the result file*'
                '\n\nChoose "no" to start at 0 position'.format(tmp_position + 1, self.processed))]
        else:
            self.position = p_num

        self.fix_process()  # store filename and position
        self.load_file(self.position)
        self.console_push('Starting with: ', self.filename, self.position + 1)
        self.reload_logic(on_start=True)  # load key word dictionaries
        self.process_precedents = self.load_precedents()
        self.load_str()
        self.manage_gui()
        # ------- load replace list ---
        self.search_entry.delete(0, 'end')
        self.replace_entry.delete(0, 'end')
        search_list, replace_list = self.get_search_replace_list(work_dir=self.work_directory)
        self.search_entry.insert(0, search_list)
        self.replace_entry.insert(0, replace_list)
        # -------- load insert list ---
        self.ins_list = [''] * 9 if 'inserts.lst' in missed_files else self.load_inserts()
        # -----------------------------
        self.highlight_blocks()
        self.EditWindow.mainloop()

    def save_precedents(self):
        with open(self.work_directory + 'precedents.mem', 'w') as precedents_file:
            json.dump(self.process_precedents, precedents_file)

    def load_precedents(self):        
        try:
            return json.load(open(self.work_directory + 'precedents.mem', 'r')) \
            if 'precedents.mem' in os.listdir(self.work_directory) else {}
        except json.decoder.JSONDecodeError:
            return {}


    def in_actions(self, word: str):
        if word in self.mut_actions or word in self.actions_list_cleared \
               or any(action in word and '-' not in (set(word) - set(action)) for action in self.actions_list_cleared):
            return True
        return False

    def in_modifiers(self, word: str):
        return (word in self.modifiers)# or (self.normalise_line(word) in self.modifiers)

    def in_logic_lists(self, word_list):
        return all(self.in_modifiers(word) or self.in_actions(word) for word in word_list)

    def _is_similar(self, check_line: str, stored_line: str, levels: list, cur_level: str):
        words1 = set(check_line.lower().split(' '))
        words2 = set(stored_line.lower().split(' '))
        extra1_in_lists, extra2_in_lists = False, False
        level_accordance = False

        common_part = words1.intersection(words2)
        extra1 = words1 - common_part
        extra2 = words2 - common_part
        diff1, diff2 = len(extra1), len(extra2)
        is_similar = diff1 <= 2 and diff2 <= 2 and len(common_part) >= min(diff1, diff2)

        if is_similar:
            extra1_in_lists = self.in_logic_lists(extra1) or len(extra1) == 0
            extra2_in_lists = self.in_logic_lists(extra2) or len(extra2) == 0
            cur_levels = cur_level.split(';')
            if len(cur_levels) == 0:
                level_accordance = True
            elif len(cur_levels) == 1:
                level_accordance = cur_level in levels
            else:
                level_accordance = set(levels) == set(cur_levels)
        return is_similar and extra1_in_lists and extra2_in_lists and level_accordance
    
    @staticmethod
    def percent_convert(mod: str, line: str):  # check if mod is percent and replace it with some qualitative mod
        result = False
        if mod != '##':
            tmp_val = re.search(mod, line, re.I).group().strip(' %').replace(nonDP, DP)
            float_check = is_float(tmp_val)
            if float_check and float(tmp_val) > 100:
                result, mod = True, 'stronger'
            elif float_check and float(tmp_val) == 100:
                result, mod = True, 'complete'
            elif float_check and float(tmp_val) < 100:
                result, mod = True, 'weak' 
            else:
                result, mod = False, mod                 
        # self.console_push(result, mod)
        return result, mod
    
    @staticmethod
    def normalise_line(line=''):
        line = line.lower().replace('  ', '')
        percent_search = re.search('[\d.,]+? *?%', line)
        percent = percent_search.group() if percent_search else ''
        line = line.replace(percent, StringEditor.percent_convert(percent, line)[1]) if percent else line
        fold_search = re.search('[\d.,]+?-fold', line, re.I)
        fold = fold_search.group() if fold_search else ''
        return line.replace(fold, 'multiple') if fold else line

    def search_precedent(self, test_line: str, codes_block):  # receive extracted description       
        precedent = ''
        current_level = codes_block.split('|')[1]
        cutted_test_line = re.split('^in.*?;\s*', test_line.strip('.').lower())[-1]
        something_found = False
        # self.console_push('>>>', test_line)        
        # messagebox.showinfo(test_line, self.process_precedents[test_line.lower()])
        if not test_line:
            return '', '', 'none'
        elif test_line in self.process_precedents:
            found_line = test_line             
            result_type = 'equal'            
            something_found = True            
        elif cutted_test_line in self.process_precedents:
            found_line = cutted_test_line 
            result_type = 'close to equal'
            something_found = True
        else:           
            found_line = ''            
            result_type = 'none'            
            for line2 in self.process_precedents:
                tested_precedent = self.process_precedents[line2]
                stored_levels = tested_precedent.split('|')[1].split(';')
                if self._is_similar(test_line, line2, stored_levels, current_level):
                    found_line = line2
                    result_type = 'similar'
                    something_found = True                    
                    break        
        return self.process_precedents[found_line] if something_found else '', found_line, result_type

    def extract_blocks(self, line='', line_norm=True):
        line_buffer = line.split(ARW if ARW in line else '\t')
        if len(line_buffer) >= 4:
            upid, vari, description, process_block = line_buffer[0:4]
            description = self.normalise_line(description) if line_norm else description
            return upid, vari, description, process_block
        else:
            return line_buffer + ['']*(4 - len(line_buffer))
    
    def replace_process_block(self, line_num: int, new_block: str):
        line = self.t_editor.get(str(line_num)+'.0', str(line_num)+'.end').strip(PRF).replace(ARW, '\t')
        block_search = re.search('\t[A-Z;?\[\]]*?\|[+-0?!r;]*\|.*\|', line)        
        if block_search:
            start, end = block_search.span()  # only CLASS|LEVEL|TARGET (without associations)
            start += 1
            self.t_editor.delete(str(line_num) + '.' + str(start), str(line_num) + '.' + str(end))
            self.editor_insert(str(line_num) + '.' + str(start), new_block)

    def use_precedents_for_all(self, _=''):
        for i in range(1, int(self.t_editor.index('end').split('.')[0])):
            self.use_precedents(i)
    
    def use_precedents(self, line_num: int):
        lnm = str(line_num)
        line = self.t_editor.get(lnm + '.0', lnm + '.end').replace(ARW, '\t').replace(PRF, '').strip('\n')
        _, _, test_line, block = self.extract_blocks(line, line_norm=True)
        test_line = test_line.split('when associated')[0].strip(',; ')
        found_precedent, found_line, result_type = self.search_precedent(test_line, block)
        # messagebox.showinfo(found_line, self.process_precedents[found_line]+'\n'+found_precedent +'\n'+result_type)
        if found_precedent:
            self.console_push('Line {} - {} line found: "'.format(line_num, result_type), found_line + '\t' + found_precedent, '"')
        found_precedent and self.replace_process_block(line_num, found_precedent) 

    def make_precedent(self):
        text_buffer = self.t_editor.get('1.0', 'end').replace(ARW, '\t').replace(PRF, '').split('\n')
        for line in text_buffer:
            upid, vari, description, block = self.extract_blocks(line, line_norm=True)
            description = re.split('^in.*?;\s*', description.split('when associated')[0].strip(',; ').lower())[-1]            
            block = block.rsplit('|', maxsplit=1)[0] + '|'                        
            self.process_precedents[description] = block if block else '|||'
            #messagebox.showinfo('', description)

    def load_inserts(self):
        buf = [line.strip('\n') for line in open(self.work_directory + 'inserts.lst', 'r')]
        while len(buf) < 10:
            buf.append('')
        return buf

    def show_ins_list(self, _=""):
        for num, line in enumerate(self.ins_list):
            self.ins_fields[num].delete(0, 'end')
            self.ins_fields[num].insert(0, line)
        self.ins_window.deiconify()
        self.ins_window.focus_set()
        return 'break'

    def use_inserts(self, _=''):
        for i in range(10):
            self.ins_list[i] = self.ins_fields[i].get()
        with open(self.work_directory+'inserts.lst', 'w', encoding='utf-8') as wfile:
            for line in self.ins_list:
                wfile.write(line+'\n')

    def reset_ins_fields(self):
        for i in range(10):
            self.ins_fields[i].configure(bg='white')

    def duplicate_line(self, _=''):
        index, line = self.current
        y = int(index.split('.')[0])
        new_index = str(y - 1) + '.0'
        self.editor_insert(new_index, line + '\n')
        self.show_tabs()
        return 'break'

    def ins_popular(self, event):
        if event.keysym in '1234567890':
            number = int(event.keysym)
            self.ins_fields[number].configure(bg='green')
            self.ins_window.update()
            time.sleep(0.1)
            self.reset_ins_fields()
            self.ins_from_list(number)
            self.add_undo_point()
            self.ins_window.withdraw()
            self.t_editor.focus_set()
            return 'break'

    def ins_from_list(self, number: int):
        if number < len(self.ins_list):
            sel_range = self.t_editor.tag_ranges(tkinter.SEL)
            if sel_range:
                self.t_editor.delete(*sel_range)
            pos, _ = self.current
            self.editor_insert(pos, self.ins_list[number])
        return 'break'

    def reload_logic(self, _='', on_start=False):
        self.mut_actions = self.load_actions(self.work_directory)
        self.modifiers = self.load_modifiers(self.work_directory)
        self.partlinkers = self.load_part_linkers(self.work_directory)
        self.replacers = self.load_replacers(self.work_directory)
        self.process_precedents = self.load_precedents()
        self.actions_list_cleared = set(action.strip('|') for action in self.mut_actions)
        if not on_start:
            messagebox.showinfo('Success', 'All keyword dictionaries have been reloaded.')

    @property
    def processed(self):  # check how many lines from current source file have been processed already
        try:
            return len(open(self.filename.rsplit('.')[0]+'_processed.tsv', 'r').readlines())
        except FileNotFoundError:
            return 0
    
    def store_current(self, _=''):
        self.virt_cursor_pos = self.current[0]

    def unpost_menus(self, _):
        self.copy_menu.unpost()
        self.ins_menu.unpost()
        self.level_menu.unpost()
        self.type_menu.unpost()

    def fix_process(self):
        with open(self.work_directory+'processing.mem', 'w', encoding='utf-8') as processing_file:
            processing_file.write(self.filename + '\t' + str(self.position) + '\n')

    @staticmethod
    def appropriate_source(source):
        if os.path.exists(source):
            with open(source, 'r', encoding='utf-8') as source_file:
                buf = source_file.readline()
                regex_pattern1 = re.compile('[A-Z]\d([A-Z0-9]{2,3}\d){1,2}', re.I)
                regex_pattern2 = re.compile('[A-z]+\|[\d-]{2,}\|[A-z]+\t.+', re.I)
                up_id, line = buf.split('\t', maxsplit=1)
                return True if re.match(regex_pattern1, up_id) and re.match(regex_pattern2, line) else False
        else:
            return False

    @staticmethod
    def get_start_point(work_dir: str):
        if os.path.exists(work_dir+'processing.mem'):
            buf = open(work_dir + 'processing.mem', 'r', encoding='utf-8').readline().split('\t')
            return buf[0].strip() if len(buf) > 0 else '', int(buf[1].strip()) if len(buf) > 1 and \
                buf[1].strip().isdigit() else 0
        else:
            return ['', 0]
    
    @staticmethod
    def get_search_replace_list(work_dir: str):
        try:
            with open(work_dir + 'rep.lst', 'r') as sr_file:
                buf = sr_file.readlines()
                search_list = [pair.split('->')[0].strip('[]\n') for pair in buf]
                replace_list = [pair.split('->')[1].strip('[]\n') for pair in buf]
            return ['|'.join(search_list), '|'.join(replace_list)]
        except:
            #  FileNotFoundError:
            return ['', '']

    def focus_set_wrp(self, _=''):
        self.search_field.focus_set()
    
    def copy_to_clipboard(self, _=''):
        if self.t_editor.tag_ranges('sel'):
            line = self.t_editor.selection_get()
            self.EditWindow.clipboard_clear()
            self.EditWindow.clipboard_append(line)

    @property
    def work_directory(self):
        directory = os.path.dirname(__file__)
        if not directory:
            directory = os.path.dirname(os.path.realpath(__file__))
        splitter = '\\' if platform.system() == 'Windows' else '/'
        return directory.replace('/', splitter) + splitter   # + splitter

    @staticmethod
    def check_files(directory_name: str):        
        return tuple(filter(lambda filename: os.path.exists(directory_name + filename), NECESSARY_FILES))

    def step_back(self, _=''):
        if self.position > 0:
            effective_name = self.filename.rsplit('.', maxsplit=1)[0] + '_processed.tsv'
            try:
                self.STOP = False
                self.position -= 1
                stop_id = '\t'.join(self.lines[self.position].split('\t')[0:2])
                lines_to_write = []

                with open(effective_name, 'r') as reading_file:
                    for line in reading_file:
                        if stop_id not in line:
                            lines_to_write.append(line)
                        else:
                            break
                with open(effective_name, 'w', encoding='utf-8') as writefile:
                    writefile.write(''.join(lines_to_write))
                self.load_str()
                self.save_in_file_position()
            except FileNotFoundError:
                self.console_push('file ', effective_name, 'not found.')

    def manage_gui(self):
        lines_left = len(self.lines)-(self.position + 1)
        mean_time = 0
        if self.stored_times:
            mean_time = sum(self.stored_times) / len(self.stored_times)
        minutes_left = mean_time * lines_left / 60

        self.file_label.configure(text='{} [line: {}/{} (1-based). m.t.= {} sec, approx. {} min left]'.
                                  format(self.filename,
                                         str(self.position + 1),
                                         len(self.lines),
                                         round(mean_time, 1),
                                         round(minutes_left, 1)
                                         ))
        if self.STOP:
            self.load_file_button.configure(state='normal')
            self.next_button.configure(state='disable')
            self.split_button.configure(state='disable')
            self.reload_string_button.configure(state='disable')
            self.undo_button.configure(state='normal')
            self.jump_button.configure(state='normal')
            self.mark_button.configure(state='disable')
        else:
            self.load_file_button.configure(state='normal')
            self.next_button.configure(state='normal')
            self.split_button.configure(state='normal')
            self.reload_string_button.configure(state='normal')
            self.jump_button.configure(state='normal')
            if len(self.undo_buffer) > 0:
                self.undo_button.configure(state='normal')
            else:
                self.undo_button.configure(state='disable')

    def save_in_file_position(self, _=''):
        if self.filename != '':
            with open(self.work_directory + 'processing.mem', 'w', encoding='utf-8') as last_file:
                last_file.write(self.filename + '\t' + str(self.position))

    def clear_tags(self, _=''):
        for tag in self.help_txt_box.tag_names():
            self.help_txt_box.tag_delete(tag)

    @staticmethod
    def descriptors_location(line: str):
        left_part = re.search('[A-z]+\|\d+-\d+\|[A-z]+(.+?)\|', line)  # removed \ before - between \d+ and \d+
        return left_part.span()[1] - 1 if left_part else -1

    @staticmethod
    def target_location(line: str):
        lp = StringEditor.descriptors_location(line)
        if lp != -1:
            target_block = re.search('\|[+-0?r!;]*?\|', line[lp:])
            pos = target_block.span()[1] if target_block else 0
            return lp + pos

    @property
    def current(self):        
        y, x = self.t_editor.index(tkinter.INSERT).split('.')
        line = self.t_editor.get(y + '.0', y + '.end')        
        return [y + '.' + x, line.replace(ARW, '\t')]
        
    def _set_cursor(self, position='', l_num=0, s_num=0):
        joined_position = '{}.{}'.format(l_num, s_num)
        self.virt_cursor_pos = position or joined_position
        self.t_editor.mark_set(tkinter.INSERT, self.virt_cursor_pos)

    def editor_insert(self, index: str, source: str):
        if '.' in index:
            y, x = index.split('.')
            if y.isdigit() and x.isdigit() and int(y) > 0 and int(x) >= 0:
                self.t_editor.insert(index, source)
                self.highlight_blocks()

    def text_search(self, _=''):
        self.clear_tags()
        first_mark = False
        pattern = self.search_field.get()
        if pattern:
            pos = '1.0'
            while pos:
                self.help_txt_box.tag_configure("highlight", background="lightblue")
                search_count = tkinter.StringVar()
                pos = self.help_txt_box.search(pattern, pos, stopindex="end", count=search_count, nocase=1)
                if pos:
                    if not first_mark:
                        self.help_txt_box.mark_set('insert', pos)
                        self.help_txt_box.see('insert')
                        first_mark = True

                    y, x = pos.split('.')
                    x2 = int(x) + int(search_count.get())
                    pos2 = y + '.' + str(x2)
                    self.help_txt_box.tag_add("highlight", pos, pos2)
                    pos = pos2

    def on_edit(self, event):
        self.store_current()
        self.highlight_blocks()
        if not (event.keysym in ('Control_L', 'Control_R', 'Alt_L', 'Alt_R', 'Left', 'Right', 'Up', 'Down', 'Shift_L',
                                 'Shift_R')):
            self.add_undo_point()
        self.manage_gui()

    def jump_to(self):
        jump_pos = simpledialog.askinteger('Jump to: ', 'Enter line number to start with\n(current line will not be '
                                           'saved!): ', initialvalue=self.position+1)
        if jump_pos and 0 < jump_pos < len(self.lines):
            self.position = jump_pos - 1
            self.STOP = False
            self.load_str()
            self.save_in_file_position()
        self.manage_gui()

    def plus_font(self):
        self.font_size += 1
        self.t_editor.configure(font=('Courier', self.font_size))
        self.help_txt_box.configure(font=('Courier', self.font_size))
        self.highlight_blocks()

    def minus_font(self):
        self.font_size -= 1
        self.t_editor.configure(font=('Courier', self.font_size))
        self.help_txt_box.configure(font=('Courier', self.font_size))
        self.highlight_blocks()

    def help(self, _=''):
        self.help_window_mode = 1
        with open(self.work_directory + 'help.txt', 'r', encoding='utf-8') as rf:
            self.help_txt_box.delete('1.0', 'end')
            self.help_txt_box.insert('1.0', rf.read())
            self.help_window.deiconify()
            self.help_window.tkraise()
            
    def show_uniprot_entry(self, _=''):
        self.load_uniprot_entry(mode=self.help_window_mode)
        self.help_window.deiconify()
        self.search_field.focus_set()
        self.help_window.tkraise()
        self.t_editor.focus_set()
                
    def load_uniprot_entry(self, mode=2):
        def upeload():
            self.help_txt_box.delete('1.0', 'end')
            self.help_txt_box.insert('1.0', 'Connecting...')
            uniprot_entry = self.read_uniprot_entry(self.upID)
            self.help_txt_box.delete('1.0', 'end')
            self.help_txt_box.insert('1.0', uniprot_entry)
        
        self.help_window_mode = 2
        if self.last_up_id != self.upID or mode != 2:
            self.last_up_id = self.upID
            newthread = threading.Thread(target=upeload)
            newthread.start()
            
    def find_in_uniprot(self, _=''):
        sel_range = self.t_editor.tag_ranges('sel')
        word = self.t_editor.get(*sel_range).replace(ARW, ' ') if sel_range else ''
        if word:
            self.search_field.delete('0', 'end')
            self.search_field.insert('0', word)
            self.text_search()
        self.show_uniprot_entry()
        self.focus_set_wrp()
    
    @staticmethod
    def read_uniprot_entry(accession: str):
        message = ''
        if accession:
            try:
                handle = request.urlopen('http://www.uniprot.org/uniprot/{}.txt'.format(accession))
                if handle:
                    buf = handle.readlines()
                    organizm = next(filter(lambda x: x.startswith('OS'), list(map(bytes.decode, buf)))).split('OS')[-1].lstrip(' ')
                    uniprot_name = filter(lambda x: x.startswith('DE'), list(map(bytes.decode, buf)))
                    uniprot_info = filter(lambda x: x.startswith('CC'), list(map(bytes.decode, buf)))

                    uniprot_name = '\n'.join(map(lambda x: x.replace('\n', '').split('=' if '=' in x else ':')[1],
                                             uniprot_name))
                    uniprot_info = ' '.join(map(lambda x: x.replace('\n', '').replace('CC   ', '').
                                                replace('-!- ', '\n\n').lstrip(' '), uniprot_info))
                    message = 'UniProt ID: {}\nOrganizm: {}\n{}\n{}'.format(accession, organizm, uniprot_name, uniprot_info)
            except request.URLError:
                message = "Connection error: UniProt database isn't accessible."
        return message

    @property
    def clipboard(self):
        try:
            return self.EditWindow.clipboard_get()
        except tkinter.TclError:
            return ''

    def paste(self):
        self.editor_insert(self.current[0], self.clipboard)
        self.add_undo_point()
        return 'break'

    def tk_text_cut(self, line_number=1, pos=0, length=0):  # PROCEDURE (NOT FUNCTION). CUTS PART OF STRING AND RETURN
        cutted = self.t_editor.get('{}.{}'.format(line_number, pos), '{}.{}'.format(line_number, pos + length))
        self.t_editor.delete('{}.{}'.format(line_number, pos), '{}.{}'.format(line_number, pos + length))
        return cutted

    def target_paste(self, mode: str, buffered=True, paste_instead='', clear_selection=True):
        delimiter = {'add': ' ', 'split': ';', 'delete': ''}[mode]
        insertion = {False: paste_instead, True: self.clipboard}[buffered]
        current_position, line = self.current
        cy = current_position.split('.')[0]
        x = self.target_location(line)
        if x != -1:
            result = re.search('[^|]*', line[x:])
            shift = ((result.span()[1] - result.span()[0]) if result else 0)
            found_target = self.tk_text_cut(line_number=int(cy), pos=x, length=shift).rstrip(' ;')
            final_insertion = '{}{}{}'.format(found_target if mode != 'delete' else '', delimiter, insertion).strip(' ')
            clear_selection and self.t_editor.tag_remove(tkinter.SEL, '1.0', tkinter.END)
            self.editor_insert('{}.{}'.format(cy, x), final_insertion)
            self.add_undo_point()
        return "break"

    def target_copy(self, mode_to_pass: str):
        sel_range = self.t_editor.tag_ranges('sel')
        activity = self.t_editor.get(*sel_range).replace(ARW, ' ') if sel_range else ''
        self.target_paste(mode=mode_to_pass, paste_instead=activity, buffered=False, clear_selection=False)
        return 'break'

    def move_to_level(self, _=''):
        pos, line = self.current
        cy = pos[0].split('.')[0]
        x = self.descriptors_location(line)
        if x != -1:
            self.t_editor.tag_remove(tkinter.SEL, '1.0', 'end')
            self._set_cursor('{}.{}'.format(cy, x + 1))
            return 'break'

    def alt_end(self, _=''):
        pos, line = self.current
        cy = pos[0].split('.')[0]
        x = self.descriptors_location(line)
        if x != -1:
            shift = re.search('(\|.*?\|)([^|]*)', line[x:])
            if shift:
                shift_length = shift.span(2)[1] - shift.span(2)[0]
                insertion_x = str(x + shift.span(1)[1] + shift_length)
                self.t_editor.tag_remove(tkinter.SEL, '1.0', 'end')
                self._set_cursor('{}.{}'.format(cy, insertion_x))
                return 'break'

    def bracket_flank(self, _=''):
        self.add_undo_point()
        sel_range = self.t_editor.tag_ranges('sel')
        if len(sel_range) > 1:
            y1, x1 = str(sel_range[0]).split('.')
            y2, x2 = str(sel_range[1]).split('.')
            x1 = int(x1)
            x2 = int(x2) + 1
            index1 = '{}.{}'.format(y1, x1)
            index2 = '{}.{}'.format(y2, x2)
            self.editor_insert(index1, '[')
            self.editor_insert(index2, ']')

    def ins_class(self, eclass='', replace=False):        
        insertion = eclass
        current_position, line = self.current
        cy = current_position.split('.')[0]
        x = self.descriptors_location(line)

        if x != -1:
            if replace:
                x = self.clear_eclasss()
            prev_eclass = [line[x - 3: x], line[x - 4: x].strip('[]?'), line[x - 5: x].strip('[]?')]
            before = ';' if any(qual in ECLASSES for qual in prev_eclass) and not replace else ''
            ins_position = cy + '.' + str(x)
            self.editor_insert(ins_position, before + insertion)
            self.add_undo_point()
            # self.highlight_blocks()
        return 'break'

    def clear_eclasss(self):
        pos, line = self.current
        line_num = pos.split('.')[0]
        start_pos = line.rindex('\t') + 1
        finish_pos = line[start_pos:].index('|') + start_pos
        if any(substring in line[start_pos: finish_pos] for substring in ECLASSES):
            pos1 = line_num + '.' + str(start_pos)
            pos2 = line_num + '.' + str(finish_pos)
            # messagebox.showinfo(pos1 + ' ' + pos2, line[start_pos:finish_pos])
            self.t_editor.delete(pos1, pos2)
        return start_pos

    def set_new_grades(self, _='', which='all'):
        lines_amount = int(self.t_editor.index('end').split('.')[0])
        if which == 'all':
            for line_number in range(1, lines_amount):
                line = self.t_editor.get(str(line_number) + '.0', str(line_number) + '.end').replace(ARW, '\t')\
                    .strip(PRF)
                self.set_level(self.deduce_grade(line, actions=self.mut_actions,
                                                 modifiers=self.modifiers), line_number=line_number, replace=True)
        elif which.startswith('#:'):
            line_numbers = which.split('#:')[1].split(',')
            for l_num in line_numbers:
                line = self.t_editor.get(l_num + '.0', l_num + '.end').replace(ARW, '\t').strip(PRF)
                self.set_level(self.deduce_grade(line, actions=self.mut_actions, modifiers=self.modifiers),
                           line_number=int(l_num), replace=True)
        else:
            self.set_level(self.deduce_grade(self.current[1], actions=self.mut_actions,
                                             modifiers=self.modifiers), replace=True)

    def set_level(self, level='0', line_number=-1, replace=False, can_nulify=True):
        # self.current_deduced_level[line_number] = level
        self.t_editor.tag_remove(tkinter.SEL, '1.0', tkinter.END)
        if line_number == -1:
            current_position, line = self.current
            cy = current_position.split('.')[0]
        else:
            cy = str(line_number)

        line = self.t_editor.get(cy + '.0', cy + '.end')

        x = self.descriptors_location(line)
        shift = re.search('\|([-+ 0?r;!]*)', line[x:] if x > -1 else '')
        if shift:  # False only when block does not exist
            shift_length = len(shift.group(1))
            current_grade = shift.group(1)
            if level == '' and can_nulify is False:
                level = current_grade

            if current_grade != '' and not current_grade.endswith('!') and not replace:
                level = ';' + level
            if current_grade.endswith('!') and level == '!':
                level = ''

            insertion_x = str(x + 1 + shift_length)
            self.editor_insert(cy + '.' + insertion_x, level)

            if replace:
                dx1 = x + 1
                dx2 = dx1 + shift_length
                self.t_editor.delete(cy + '.' + str(dx1), cy + '.' + str(dx2))

            self.add_undo_point()
            self.t_editor.tag_remove(tkinter.SEL, '1.0', tkinter.END)
            return 'break'

    def question_mark_3rd_block(self, _=None):
        self.t_editor.tag_remove(tkinter.SEL, '1.0', tkinter.END)
        current_position, line = self.current
        cy = current_position.split('.')[0]
        x = self.descriptors_location(line)
        if x != -1:
            shift = re.search('(\|.*?\|)([^|]*)', line[x:])
            if shift:
                shift_length = shift.span(2)[1] - shift.span(2)[0]
                insertion_x = str(x + shift.span(1)[1] + shift_length)
                insertion = '?' if shift_length == 0 else ';?'
                self.editor_insert(cy + '.' + insertion_x, insertion)
                self.add_undo_point()
                self._set_cursor('{}.{}'.format(cy, str(int(insertion_x) + 1)))

    def open_new_source(self, _=''):
        try_name = filedialog.askopenfilename(initialdir="/" if platform.system == 'Windows' else '.')
        if try_name:
            self.filename = try_name
            self.load_file(pos=0)
            self.fix_process()
            self.load_str()
        self.manage_gui()

    def load_file(self, pos=-1):
        # pos id only marker! file will be loaded from 0 always!
        if self.filename:
            with open(self.filename, 'r') as sf:
                self.lines = sf.readlines()
            self.position = pos if pos < len(self.lines) else len(self.lines)
            self.STOP = False if self.position < len(self.lines) else True

    def move_to_description(self, _=''):
        y = self.t_editor.index(tkinter.INSERT).split('.')[0]
        line = self.t_editor.get(str(y) + '.0', str(y) + '.end')
        x = self.descriptors_location(line)        
        if x != -1:
            self.t_editor.tag_remove(tkinter.SEL, '1.0', 'end')
            self._set_cursor('{}.{}'.format(y, x))

    def move_to_description_start(self, _=''):
        pos, line = self.current
        line = line.replace(ARW, '\t')
        y, x = pos.split('.')
        pos = re.search('\t.+?\t', line)
        self.t_editor.tag_remove(tkinter.SEL, '1.0', 'end')
        self._set_cursor('{}.{}'.format(y, pos.end() if pos else x))
        return 'break'
    
    @staticmethod
    def alt_index(line: str, stops: str):
        indexes = [line.index(key) for key in stops if key in line]
        return min(indexes) if indexes else len(line)

    @staticmethod
    def alt_rindex(line: str, stops: str):
        indexes = [line.rindex(key) for key in stops if key in line]
        return max(indexes) if indexes else 0

    """    
    def re_split_pos(line: str, pattern: ''):
        positions = re.finditer(pattern, line)
        pos_list = [pos.span() for pos in positions]
    """

    @staticmethod
    def words_positions(line: str, delimiter: str):
        starts = []
        for pos, key in enumerate(line):
            if key != delimiter and (pos == 0 or line[pos - 1] == delimiter):
                starts.append(pos)
        if not starts:
            starts.append(0)
        pairs = []
        for start in starts:
            if delimiter in line[start:]:
                end = start + line[start:].index(delimiter)-1
            else:
                end = len(line) - 1
            pair = (start, end)
            pairs.append(pair)
        return list(filter(lambda x: x[1]-x[0] > 0, pairs))

    def to_next_word(self, _=''):
        self.move_sel(mode='common', direction='r', select=False)
        return 'break'
        
    def to_previous_word(self, _=''):
        self.move_sel(mode='common', direction='l', select=False)
        return 'break'

    def ctrl_select_right(self, _=''):
        pass

    def ctrl_select_left(self, _=''):
        pass

    @staticmethod
    def current_word_location(locations: list, line_pos: int):
        for i, loc in enumerate(locations):
            if loc[0] < line_pos <= loc[1]:
                return [i]
        for i in range(len(locations)-1):
            if locations[i][1] < line_pos <= locations[i+1][0]:
                return [i, i + 1]
        if line_pos <= locations[0][0]:
            return [0]
        if line_pos > locations[-1][1]:
            return [len(locations) - 1]
        return -1

    @staticmethod
    def next_word_location(locations: list, index, direction: str):
        if index == -1:
            return [-1, -1]
        #  step = 1 if direction == 'r' else -1
        if len(index) == 1:
            return locations[index[0]]
        else:
            return locations[index[0 if direction == 'l' else 1]]

    def move_sel(self, direction: str, select=True, mode='common'):
        stops = {'common': STOP_SEQUENCE, 'strict': BIG_STOP_SEQUENCE, 'loosed': SMALL_STOP_SEQUENCE}
        self.t_editor.tag_remove(tkinter.SEL, '1.0', 'end')
        stop_sequence = stops[mode]
        stored_pos = self.virt_cursor_pos
        line = self.current[1]
        y, x = stored_pos.split('.')
        x = int(x) if x.isdigit() else len(line)
        line = ''.join([i if i not in stop_sequence else '|' for i in line])
        locations = self.words_positions(line, '|')
        current_word_number = self.current_word_location(locations, x)
        sel_s, sel_e = self.next_word_location(locations, current_word_number, direction)
        if sel_s == -1 or sel_e == -1:
            return 'break'
        spc = 1
        new_pos = '{}.{}'.format(y, (sel_e + spc) if direction == 'r' else sel_s)
        self._set_cursor(new_pos)
        if select:
            self.t_editor.tag_add(tkinter.SEL, '{}.{}'.format(y, sel_s), '{}.{}'.format(y, sel_e + spc))
        return 'break'

    def move_selection_right(self, _=''):
        self.move_sel(mode='common', direction='r')
        return 'break'

    def strict_move_selection_right(self, _=''):
        self.move_sel(mode='strict', direction='r')
        return 'break'

    def move_selection_left(self, _=''):
        self.move_sel(mode='common', direction='l')
        return 'break'

    def strict_move_selection_left(self, _=''):
        self.move_sel(mode='strict', direction='l')
        return 'break'

    def loose_move_selection_right(self, _=''):
        self.move_sel(mode='loosed', direction='r')
        return 'break'

    def loose_move_selection_left(self, _=''):
        self.move_sel(mode='loosed', direction='l')
        return 'break'

    def clear_editor_tags(self, _=''):
        self.t_editor.tag_remove('highlight', '1.0', tkinter.END)
        self.t_editor.tag_remove(tkinter.SEL, '1.0', tkinter.END)
        self.excision1 = ['', 0]

    def show_tabs(self, _=''):
        bb = self.t_editor.get('1.0', 'end').strip('\n')
        showing = bb.replace('\t', ARW)
        if showing != bb:
            self.t_editor.delete('1.0', 'end')
            self.editor_insert('1.0', showing)
        self.t_editor.focus_set()

    def add_undo_point(self, _='', source_string='', mode='add'):
        if source_string != '':
            bb = source_string.strip('\n')
        else:
            bb = self.t_editor.get('0.0', 'end').strip('\n')

        if bb and bb not in self.undo_buffer[-1:]:
            if len(self.undo_buffer) > 100:
                self.undo_buffer.pop(0)
            elif mode == 'replace':
                self.undo_buffer.clear()
            self.undo_buffer.append(bb)
            self.show_tabs()
            self.manage_gui()

    def undo(self, _=''):
        current_position = self.current[0]
        if len(self.undo_buffer) > 1:
            self.t_editor.delete('1.0', 'end')
            _ = self.undo_buffer.pop()
            self.editor_insert('1.0', self.undo_buffer[-1])
            self.show_tabs()
        self.manage_gui()
        self._set_cursor(current_position)

    def show_replace_window(self, _=''):
        self.replace_window.deiconify()
        self.replace_window.tkraise()
        self.search_entry.focus_set()
        return 'break'

    def replace_words(self, _=''):
        location = self.current[0]
        search_list = self.search_entry.get().split('|')
        replace_list = self.replace_entry.get().split('|')
        text = self.t_editor.get('1.0', 'end')

        if len(search_list) != len(replace_list):
            messagebox.showerror('Error in search list', 'List of search targets and list of replacements have '
                                                         'unequal length!')
        else:
            for index, a in enumerate(search_list):
                b = replace_list[index]
                if not a.startswith('re#'):
                    text = text.replace(a, b)
                else:
                    text = re.sub(a.replace('re#', ''), b, text)

        self.t_editor.delete('1.0', 'end')
        self.add_undo_point()
        self.editor_insert('1.0', text.rstrip('\n'))
        self.add_undo_point()
        self.use_precedents_for_all()
        self._set_cursor(location)
        return 'break'

    def close_replace_dialog(self, _=''):
        with open(self.work_directory + 'rep.lst', 'w', encoding='utf-8') as writing_file:
            search_list = self.search_entry.get().split('|')
            replace_list = self.replace_entry.get().split('|')
            if search_list != '' and replace_list != '':
                writing_file.write('\n'.join(['->'.join(map(lambda x: '[' + x + ']', 
                                                            line)) for line in zip(search_list, replace_list)]))
        self.replace_window.withdraw()

    def alter_select_word(self, _=''):
        self.select(stop_sequence=BIG_STOP_SEQUENCE)
        return 'break'

    def select_word(self, _=''):
        self.select(stop_sequence=STOP_SEQUENCE)
        return 'break'

    def select(self, stop_sequence: str):
        self.t_editor.tag_remove(tkinter.SEL, '1.0', tkinter.END)        
        current_position, line_buffer = self.current
        y = int(current_position.split('.')[0])
        start = int(current_position.split('.')[1])
        finish = int(current_position.split('.')[1])
        while start > 0 and not (line_buffer[start - 1] in stop_sequence):
            start -= 1
        while finish < len(line_buffer) and not (line_buffer[finish] in stop_sequence):
            finish += 1
        self.t_editor.tag_add(tkinter.SEL, str(y) + '.' + str(start), str(y) + '.' + str(finish), tkinter.END)
        
    def mem_excision1(self, _=''):
        if self.t_editor.tag_ranges('sel'):
            self.t_editor.tag_remove('highlight', '1.0', tkinter.END)
            self.excision1 = ['', 0]
            selection_start = self.t_editor.index('sel.first')
            selection_end = self.t_editor.index('sel.last')
            self.excision1 = [self.t_editor.get(selection_start, selection_end).replace(ARW, '\t'),
                              int(selection_start.split('.')[1])]
            self.t_editor.tag_configure("highlight", background="red")
            self.t_editor.tag_add("highlight", selection_start, selection_end)
            self.t_editor.tag_remove(tkinter.SEL, '1.0', tkinter.END)
        return 'break'

    def split_line_no_precedents(self, _=''):
        self.split_line(consider_precidents=False)
        return 'break'
   
    def split_line(self, _='', consider_precidents=True):
        if self.t_editor.tag_ranges('sel'):
            splitter = {True: self.split1, False: self.split2}  # two variants of split function
            selection_start = self.t_editor.index('sel.first')
            selection_end = self.t_editor.index('sel.last')
            selection_y_f, selection_x_f = selection_start.split('.')
            selection_y_l, selection_x_l = selection_end.split('.')
            y_pos = selection_y_f
            cursor_pos, _ = self.current
            selection = [int(selection_y_f), int(selection_x_f), int(selection_y_l), int(selection_x_l)]
            line = self.t_editor.get(y_pos + '.0', y_pos + '.end').replace(ARW, '\t').strip(PRF)
            new_lines = splitter[self.excision1[0] == ''](line, selection, self.excision1, 
                                                          self.partlinkers, self.replacers)  # splitter chose 
            if not new_lines:
                self.t_editor.tag_remove('highlight', '1.0', tkinter.END)
                self.excision1 = ['', 0]
                return None
            self.t_editor.delete(y_pos + '.0', y_pos+'.end')
            self.editor_insert(y_pos + '.0', '\n'.join(new_lines))
            self.console_push('Line splitting: ')
            self.iter_print(map(lambda x: x.replace(ARW, '\t').strip(PRF), new_lines), prefix='New line', postfix=':',
                       counter=False)
            self.add_undo_point(mode='add')
            self.set_new_grades(which='#:{},{}'.format(y_pos, int(y_pos) + 1))
            self.add_undo_point()
            if consider_precidents:
                self.use_precedents(int(y_pos))
                self.use_precedents(int(y_pos) + 1)
                self.add_undo_point(mode='add')

            self.add_undo_point()
            self._set_cursor(cursor_pos)
            self.t_editor.tag_remove('highlight', '1.0', tkinter.END)
            self.excision1 = ['', 0]

    @staticmethod
    def _starts_with_any(line: str, lst: list):
        for l in lst:
            if line.lower().startswith(l.lower()):
                return True, l
        return False, ''

    @staticmethod
    def _include_any(line: str, lst: list):
        for target, rep in lst:
            if re.search(target, line, re.I):  # in line.lower():
                return True, target, rep
        return False, '', ''

    @staticmethod
    def post_process(source: str, garbage_pairs: list):
        line = source
        included = True
        endless_cycle_counter = 0
        while included and endless_cycle_counter < 10:
            included, target, rep = StringEditor._include_any(line, garbage_pairs)
            if included:
                capital_checker = re.search(target, line, re.I)
                rep = rep.capitalize() if capital_checker and is_capital(capital_checker.group()) else rep
                line = re.sub(target, rep, line, flags=re.I)
                endless_cycle_counter += 1
        buf = line.split('\t')
        capital_index = len(buf[0])+len(buf[1])+2        
        return capitalize_index(line, index=capital_index)

    @staticmethod
    def clear_part_linkers(line: str, part_linkers: list):
        starts_with_pl = True
        while starts_with_pl:
            starts_with_pl, pl = StringEditor._starts_with_any(line, part_linkers)
            line = re.sub(pl, '', line, count=1, flags=re.I).strip(' ')
        return line

    @staticmethod
    def exclude_association(line: str, a_mark: str):
        if line.strip(' ;').startswith(a_mark):
            aa = StringEditor.get_aa(line.split(a_mark)[1]).split(';')
            if aa and aa[-1] in line:
                part0, rp = line.split(aa[-1])
                ap = '; ' + part0.lstrip(' ;') + aa[-1]
                return rp, ap, True
            else:
                return line, '', True
        else:
            if a_mark in line:
                rp, a = line.split(a_mark)
                return rp, '; ' + a_mark + a, False
            else:
                return line, '', False

    @staticmethod
    def split1(line: str, selection: list, _: list, parts_linkers: list, replacers: list):
        selection_y_f, selection_x_f, selection_y_l, selection_x_l = selection
        excision = StringEditor.clear_part_linkers(line[selection_x_f: selection_x_l].strip('/\\').lstrip(')').rstrip('('), parts_linkers)

        a_mark = 'When associated ' if 'When associated ' in line else 'when associated '

        buf = re.search('\t([^|]+?)\t', line)
        description = re.split(a_mark, buf.group(1), re.I)[0].rstrip('; ') if buf else ''
        if excision in description:
            left_part = line[:selection_x_f].rstrip('/\\(;').lstrip(')').strip(' ')
            right_part, ending = line[selection_x_l:].rsplit('\t', 1)
            right_part, associate_part, only_r_p = StringEditor.exclude_association(right_part, a_mark)
            right_part = StringEditor.clear_part_linkers(right_part.strip('\t; '), parts_linkers)

            if left_part[-1] == '\t' and right_part.lower()[0] in ALPHABET:
                right_part = right_part[0].capitalize() + right_part[1:]

            e_sel = {'a': {False: associate_part, True: ''}, 'e': {False: ending, True: '|||¶'}}

            spacer = '' if left_part[-1] in ['\t', ARW] else ' '            
            new_line1 = StringEditor.post_process('{}{}{}{}\t{}'.format(left_part, spacer, excision.rstrip('; '),
                                                                        e_sel['a'][only_r_p], e_sel['e'][only_r_p]),
                                                  replacers).strip(PRF) + PRF
            new_line2 = StringEditor.post_process('{}{}{}{}\t{}'.format(left_part, spacer, right_part, associate_part,
                                                                        ending), replacers).strip(PRF) + PRF
            
            return [new_line1, new_line2]
        return []

    @staticmethod
    def split2(line: str, selection: list, excision: list, parts_linkers: list, replacers: list):

        selection_y_f, selection_x_f, selection_y_l, selection_x_l = selection

        excision2 = StringEditor.clear_part_linkers(line[selection_x_f: selection_x_l].strip(' \t'), parts_linkers)
        excision1 = StringEditor.clear_part_linkers(excision[0], parts_linkers)

        a_mark = 'When associated ' if 'When associated ' in line else 'when associated '

        buf = re.search('\t([^|]+?)\t', line)
        description = buf.group(1) if buf else ''
        description = re.split(a_mark, description, re.I)[0].rstrip('; ')

        if excision1 in description and excision2 in description:  # and not(excision2 in excision1):
            left_part = line[:excision[1]].rstrip('/\\(').strip(' ')
            right_part, ending = line[selection_x_l:].rsplit('\t', 1)
            right_part, associate_part, orp = StringEditor.exclude_association(right_part, a_mark)

            if not orp:
                right_part = StringEditor.clear_part_linkers(right_part.strip('\t; '), parts_linkers)
                excision2 = StringEditor.clear_part_linkers(excision2, parts_linkers)

                if left_part[-1] == '\t' and excision1.lower()[0] in ALPHABET:
                    excision1 = excision1[0].capitalize() + excision1[1:]
                if left_part[-1] == '\t' and excision2.lower()[0] in ALPHABET:
                    excision2 = excision2[0].capitalize() + excision2[1:]

                spacer = '' if left_part[-1] in '\t' + ARW else ' '
                new_line1 = StringEditor.post_process('{}{}{} {}{}\t{}'.format(left_part, spacer, excision1,
                                                                               right_part, associate_part,
                                                                               ending), replacers).strip(PRF)+PRF
                new_line2 = StringEditor.post_process('{}{}{} {}{}\t{}'.format(left_part, spacer, excision2,
                                                                               right_part, associate_part,
                                                                               ending), replacers).strip(PRF)+PRF
                return [new_line1, new_line2]
        return []

    def next_string(self, _=''):
        tmp_time = time.time() - self.stored_time
        if tmp_time < 60:
            self.stored_times.append(tmp_time)
        self.stored_time = time.time()

        if not self.STOP:
            self.store_line()
            self.make_precedent()
            self.save_precedents()
            self.position += 1

            if self.position < (len(self.lines)):
                self.load_str()
            else:
                messagebox.showinfo('', 'End of file reached')
                self.STOP = True
                self.t_editor.delete('0.0', 'end')

            self.save_in_file_position()
            self.manage_gui()
        return 'break'

    def store_line(self):
        lines_to_store = self.t_editor.get('1.0', 'end')
        if lines_to_store:
            lines_to_store = lines_to_store.replace(ARW, '\t').replace('\t ',
                                                                       '\t').replace(' \t', ' \t').replace('\n', '')

            pid_list = list(map(lambda x: x[0], re.findall("([A-Z]\d([A-Z0-9]{2,3}\d){1,2}.[A-z]+\|\d+-\d+\|[A-z]+)",
                                                           lines_to_store)))
            lines = []
            for pid in pid_list.__reversed__():
                pos = lines_to_store.rindex(pid)
                lines.append(lines_to_store[pos:])
                lines_to_store = lines_to_store[:pos]

            lines_to_store = '\n'.join(map(lambda x: x.replace(PRF, '').rstrip('|'), lines.__reversed__()))

            self.console_push('PROCESSED:')
            self.console_push(lines_to_store)
            terminal_size = shutil.get_terminal_size().columns
            self.console_push('=' * terminal_size)

            with open(self.filename.replace('.tsv', '_processed.tsv'), 'a', encoding='utf-8') as destination_file:
                destination_file.write(lines_to_store + '\n')
            with open(self.filename.replace('.tsv', '_lines.log'), 'a', encoding='utf-8') as logfile:
                logfile.write(str(self.position+1)+':\t' + lines_to_store.replace('\n', '\n\t\t').rstrip('\t') + '\n')

    def on_exit(self, _=''):
        if self.filename != '' and messagebox.askyesno('', 'Do You really want to quit?'):
            self.stop_editor()
        else:
            pass

    def clear_undo(self):
        self.undo_buffer = []

    @staticmethod
    def parse_string(s: str):
        up_id, variant, description = s.split('\t')[0:3]
        description = re.split('\. ',  re.sub('\.(?=[A-Z])', '. ', description))
        parse_line = list(map(lambda x: '{}\t{}\t{}'.format(up_id, variant, x[0].capitalize() + x[1:]), description))
        for i in range(len(parse_line)):
            if parse_line[i].count('when associated') > 1:
                messagebox.showerror('Syntax error', 'Syntax error in source line found!\nTry to check punctuation '
                                                     '(parts with different sense and with different association lists '
                                                     'should be separated by ".", and associations - by "," or "and" '
                                                     'not by ";")')
                return ''
            aa_description = ''
            if 'when associated' in parse_line[i]:
                aa_description = StringEditor.get_aa(parse_line[i].split('when associated')[1] + '\t')
            parse_line[i] = parse_line[i].strip('\n.') + '\t|||' + aa_description + PRF
        return '\n'.join(parse_line)

    def load_str(self, _='', consider_precedents=True):
        if not self.STOP:
            self.clear_undo()
            source_string = self.lines[self.position]
            new_id = source_string.split('\t')[0]
            if new_id == self.upID:
                self.id_field.configure(bg='green', text='   Current ID: ' + self.upID, anchor='w',
                                        font=("Courier", 10, 'bold'), fg='white')
            else:
                self.id_field.configure(bg='yellow', text='   Current ID: ' + new_id, anchor='w',
                                        font=("Courier", 10, 'bold'), fg='blue')
                self.upID = new_id

            self.console_push('CURRENT LINE NUMBER:', self.position + 1)
            self.console_push('ORIGINAL:')
            self.console_push(source_string.replace(PRF, ''))
            parsed = self.parse_string(source_string)
            
            if parsed.count('\n') > 1:
                self.console_push('Line autosplitting:')
                self.iter_print(prefix='New line', postfix=':', counter=True,
                           source=parsed.replace(ARW, '\t').replace(PRF, '').split('\n'))

            if not parsed:
                self.stop_editor()
            
            self.t_editor.delete('1.0', 'end')
            self.editor_insert('1.0', parsed)
            self.add_undo_point(mode='replace')

            splited_parsed = parsed.strip(PRF).replace('\n', '').split(PRF)
            
            for num, line in enumerate(splited_parsed):
                self.add_undo_point()
                self.set_level(self.deduce_grade(line.strip('\n'), actions=self.mut_actions,
                                                 modifiers=self.modifiers), num + 1, replace=True,
                               can_nulify=False)
                if consider_precedents:
                    self.use_precedents(num + 1)
            
            self._set_cursor('1.end')
            self.add_undo_point(mode='add')
            self.load_uniprot_entry()
    
    @staticmethod
    def load_part_linkers(work_directory: str):
        with open(work_directory + 'partlinkers.lst') as linkerfile:
            return list(filter(None, linkerfile.read().strip('\n').split('|')))
            
    @staticmethod
    def load_replacers(work_directory: str):
        replacers = []
        with open(work_directory + 'replacers.lst') as replacerfile:
            for line in replacerfile:                
                target, replacement = line.strip('\n').rsplit('|', maxsplit=1)                
                if target and replacement:
                    replacers.append((target, replacement))
        return list(filter(lambda x: x[0] != '' and x[1] != '', replacers))
    
    @staticmethod
    def load_actions(work_directory: str):
        levels = ['--', '-', '0', '+', '++', '?', 'r']
        actions = {}
        with open(work_directory + 'actions.lst', 'r') as actions_file:
            lines = actions_file.readlines()
        if len(lines) > 6:
            for line_number, line in enumerate(lines[:7]):
                actions.update({i: levels[line_number] for i in line.split(':\t')[1].replace('\n', '').
                               split('\t')})
        actions.update({'##': '##'})
        # self.console_push(actions)
        return actions

    @staticmethod
    def load_modifiers(work_directory):
        modifiers = {}
        with open(work_directory + 'modifiers.lst', 'r') as modifiers_file:
            header = list(filter(lambda x: x, modifiers_file.readline().strip('\n').split('\t')))
            delimiter = modifiers_file.readline()
            if delimiter[0:3] != '---':
                StringEditor.console_push('please insert at least "---" after the header line in the modifiers.lst file')
                exit()
            for line in modifiers_file:
                line_buffer = list(filter(lambda x: x, line.strip('\n').split('\t')))
                tmp_dict = dict(zip(header[:-1], line_buffer[:-1]))
                if len(line_buffer) == 9:
                    modifiers[line_buffer[-1]] = tmp_dict
        if '##' not in modifiers:
            modifiers.update({'##': {'--': '--', '-': '-', '0': '0', '+': '+', '++': '++', '?': '?', 'r': 'r',
                                     '##': '##'}})
        # self.console_push(modifiers)
        return modifiers

    @staticmethod
    def pattern_prep(action: str, modifier=''):
        action = action.replace('##', '') if modifier else action
        pre = action.startswith('|')
        post = action.endswith('|')
        delim = {True: r'\W+', False: r'\w*'}
        action = action.strip('|')
        link = r'\W*\w*\W*{}'.format(delim[pre]) if action and modifier else ''
        pattern = r'(^|{}){}{}{}({}|\Z)'.format(delim[True if not action else pre],
                                                modifier, link, action,
                                                delim[post if action else True])
        return pattern

    @staticmethod
    def action_search(line: str, actions: dict):
        return list(filter(lambda x: re.search(StringEditor.pattern_prep(action=x),
                                               line.split('\t', maxsplit=2)[-1], re.IGNORECASE), 
                           actions.keys()))                                             # contains UNMODIFIED patterns

    @staticmethod
    def action_choose(actions: dict, line: str):  # chose most left effect key word        
        found_actions = StringEditor.action_search(line, actions)
        if len(found_actions) == 0:
            return '##'
        else:  # pattern_prep here doesn't wait any modifiers !!!
            indexed = [re.search(StringEditor.pattern_prep(patt), line, re.IGNORECASE).span() for patt in found_actions]
            left_pattern_start = min([i[0] for i in indexed])
            sub_indexed = list(filter(lambda x: x[0] == left_pattern_start, indexed))
            if len(sub_indexed) > 1:
                right_pattern_end = max([i[1] for i in sub_indexed])
                sub_indexed = list(filter(lambda x: x[1] == right_pattern_end, sub_indexed))
            return found_actions[indexed.index(sub_indexed[0])]

    @staticmethod
    def mod_search(modifiers: dict, action: str, line: str):
        found_mods = list(filter(lambda mod: re.search(StringEditor.pattern_prep(action, modifier=mod), line, re.I),
                            modifiers))                              # only search modifiers near some action
        if action == '##' and len(found_mods) > 0:                                           
            maped_mods = {re.search(mod, line, re.I).span()[0]: mod for mod in found_mods}
            return (maped_mods[max(maped_mods.keys())],)
        else:
            return found_mods
        
    @staticmethod
    def mod_choose(modifiers: dict, action: str, line):
        mod_list = StringEditor.mod_search(modifiers, action, line)
        return max(mod_list, key=len) if len(mod_list) > 0 else '##'


    def deduce_grade(self, source_line: str, actions: dict, modifiers: dict, line_norm=True):        
        source_line = source_line.split('\t')[2] if '\t' in source_line else source_line
        line = self.normalise_line(source_line) if line_norm else source_line
        action_found = self.action_choose(actions, line)
        change = actions[action_found]        
        mod_found = self.mod_choose(modifiers, action_found, line)
        #self.console_push('action: {}; modifier: {}'.format(action_found, mod_found))
        # Mods are used with chosen action (they must be paired or delimited by one word in a sentence).
        # If action is ## - mods being analysed independently
        return modifiers[mod_found][change].replace('##', change.replace('##', ''))

    @staticmethod
    def get_aa(line: str):
        aa_list = re.findall(AAPATTERN, line, re.I)
        buf = []
        for pair in aa_list:
            buf.extend(pair)
        aa_list = filter(lambda x: x, buf)
        return ';'.join(aa_list)

    def view_source(self, _=''):
        self.help_window_mode = 3
        with open(self.filename, 'r') as rf:
            self.help_txt_box.delete('1.0', 'end')
            show_text = ''
            for num, line in enumerate(rf.readlines()):
                show_text += str(num + 1) + '\t' + line
            self.help_txt_box.insert('1.0', show_text)
            self.help_window.deiconify()
            self.help_window.tkraise()
            self.help_txt_box.tag_configure("highlight", background="lightblue")
            self.help_txt_box.tag_add('highlight', '{}.0'.format(self.position + 1), '{}.end'.format(self.position + 1))
            self.help_txt_box.mark_set('insert', '{}.0'.format(self.position + 1))
            self.help_txt_box.see('insert')

    @staticmethod
    def auto_check(filename=''):
        m = tkinter.Tk()
        m.withdraw()
        from tkinter import simpledialog
        re_dict = {i.split('\t')[0]: i.split('\t')[1].replace('\n', '') for i in open('autocheck.lst', 'r')}

        StringEditor.console_push(re_dict)
        if not filename:
            return 'break'
        else:
            with open(filename, 'r') as file_to_examine:
                exam_lines = file_to_examine.readlines()
                lines_to_store = []
                for line in exam_lines:
                    StringEditor.console_push(line)
                    for pattern in re_dict:
                        if re.search(pattern, line):
                            StringEditor.console_push('Pattern found: \n', line)
                            if re_dict[pattern]:
                                line = re.sub(pattern, re_dict[pattern], line)
                                StringEditor.console_push('Replaced: \n', line)
                            else:
                                line = simpledialog.askstring(title='Pattern found:',
                                                              prompt=line,
                                                              initialvalue=line.replace('\t', ARW)).replace(ARW, '\t')
                                StringEditor.console_push('Replaced: \n', line)
                    lines_to_store.append(line)

    def highlight_blocks(self):
        tags = ['e_class', 'level', 'target', 'aa_linked']
        locator = dict(zip(tags, (self.loc_classes, self.loc_levels, self.loc_target, self.loc_aa_linkage)))
        full_text = self.t_editor.get('1.0', 'end')
        for tag_name in tags:
            self.t_editor.tag_remove(tag_name, '1.0', 'end')
        for ln, line in enumerate(filter(lambda x: x, full_text.split('\n'))):
            for block_type in tags:
                block_locs = locator[block_type](line)
                self.t_editor.tag_configure(block_type, font='Courier {} bold'.format(self.font_size))
                for str_index1, str_index2 in block_locs:
                    location = '{}.{}'.format(ln + 1, str_index1), '{}.{}'.format(ln + 1, str_index2)
                    self.t_editor.tag_add(block_type, *location)
        self.t_editor.tag_raise('sel')
        return 'break'

    @staticmethod
    def loc_classes(tested_line=''):
        return [(loc.start() + 1, loc.end()) for loc in re.finditer(CLASS_REGEX, tested_line)]
    
    @staticmethod
    def loc_levels(tested_line=''):
        tested_line = tested_line.replace('|', '\t', 2)
        if '|' in tested_line:
            first_part, blocks = tested_line.split('|')[0:2]
            shift = len(first_part)
            return [(loc.start() + shift + 1, loc.end() + shift + 1) for loc in re.finditer(LEVEL_REGEX, blocks)]
        else:
            return []

    @staticmethod
    def loc_target(tested_line=''):
        tested_line = tested_line.replace('|', '\t', 3)
        if '|' in tested_line:
            first_part, blocks = tested_line.split('|')[0:2]
            shift = len(first_part)
            return [(loc.start() + shift + 1, loc.end() + shift + 1) for loc in re.finditer(TARGET_REGEX, blocks)]
        else:
            return []

    @staticmethod
    def loc_aa_linkage(tested_line=''):
        tested_line = tested_line.replace('|', '\t', 4)
        if '|' in tested_line:
            first_part, blocks = tested_line.split('|', maxsplit=1)
            shift = len(first_part)
            return [(loc.start() + shift + 1, loc.end() + shift + 1) for loc in re.finditer(AALINK_REGEX, blocks)]
        else:
            return []

    @staticmethod
    def focus_on(object_to_focus_on):
        object_to_focus_on.focus_set()

    def iter_print(self, source, prefix='', postfix='', counter=False, split=True, delimiter=' ', mode='', index=0,
                   index1=0, index2=0):
        try:

            for c, line in enumerate(source):
                if split and mode == 'range' and index1 < index2:
                    output = line.split(delimiter)[index1:index2]
                elif split and mode == 'index':
                    output = line.split(delimiter)[index]
                elif split and mode == 'left_section':
                    output = line.split(delimiter)[index:]
                elif split and mode == 'right_section':
                    output = line.split(delimiter)[:index]
                else:
                    output = line
                try:
                    self.console_push(prefix, (c + 1) if counter else '', postfix, output)
                except UnicodeEncodeError:
                    self.console_push('String encoding error.')
        except TypeError:
            self.console_push('non interable')

    def console_push(self, *args):        
        lines_number = int(self.console.index('end').split('.')[0])
        output = ''.join(map(str, args))
        self.console.insert('end', '\n' + output)
        print(*args)
        if lines_number > 1000:
            self.console.delete('1.0', '1.end')
        self.console.see('end')


def v_print(s):
    try:
        for line in s:
            print(line)
    except TypeError:
        print('non interable')


def is_capital(line=''):
    return line[0] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'


def capitalize_index(line='', index=0):
    return line[:index]+line[index].capitalize()+line[index+1:]


def is_float(value: str):
    try:
        _ = float(value)
        return True
    except ValueError:
        return False



def main():

    file_name = ''
    if '-f' in sys.argv:
        index = sys.argv.index('-f') + 1
        if len(sys.argv) > index:
            file_name = sys.argv[index]

    pos_number = -1
    if '-n' in sys.argv:
        index = sys.argv.index('-n') + 1
        if len(sys.argv) > index:
            pos_number = int(sys.argv[index]) if sys.argv[index].isdigit() else -1
            print('Starting from {} position'.format(pos_number))

    if '--check' in sys.argv:
        index = sys.argv.index('--check') + 1
        if len(sys.argv) > index:
            file_name = sys.argv[index]
            StringEditor.auto_check(file_name)
    elif '--check-function' in sys.argv:
        index = sys.argv.index('--check') + 1
        if len(sys.argv) > index:
            function_name = sys.argv[index]
            if '(' in function_name and ')' in function_name:
                parameters = function_name.strip('()').split(',')
                function_name = function_name.split('(')[0]
                messagebox.showinfo('run function {}'.format(function_name), 'Run with parameters: {}'.format(';'.join(parameters)))
                getattr(StringEditor, function_name)(*parameters)

    elif '--profile' in sys.argv:
        cProfile.run('StringEditor().start_editor(f_name="{}", p_num={})'.format(file_name, pos_number), 'results.stat')
        pstats.Stats('results.stat').sort_stats('cumulative').print_stats()
    else:
        StringEditor().start_editor(f_name=file_name, p_num=pos_number)





main()
